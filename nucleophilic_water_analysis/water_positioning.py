#!/Library/Frameworks/Python.framework/Versions/2.7/bin/python
# ----------------------------------------
# USAGE:

# python water_positioning.py config_file 

# ----------------------------------------
# PREAMBLE:

import numpy as np
import sys
import os
import MDAnalysis
from MDAnalysis.analysis.align import *
from distance_functions import *

flush = sys.stdout.flush
zeros = np.zeros
sqrt = np.sqrt
sums = np.sum
square = np.square
dot = np.dot
arccos = np.arccos
mean = np.mean
unit_conversion = 180./np.pi

config_file = sys.argv[1]

# ----------------------------------------
# FUNCTIONS: 

def ffprint(string):
	print '%s' %(string)
        flush()

necessary_parameters = ['pdb','traj_loc','start','end','pocket_selection','pocket_radius','wat_resname','wat_O_name','wat_H_name','substrate_atom1','substrate_atom2','base_atom1','base_atom2','base_atom3']
all_parameters = ['pdb','traj_loc','start','end','pocket_selection','pocket_radius','wat_resname','wat_O_name','wat_H_name','substrate_atom1','substrate_atom2','base_atom1','base_atom2','base_atom3','write_summary','summary_filename','nucl_wat_outputname','avg_wat_outputname','center_of_geometry_filename'] 

def config_parser(config_file):	# Function to take config file and create/fill the parameter dictionary 
	for i in range(len(necessary_parameters)):
		parameters[necessary_parameters[i]] = ''

	# SETTING DEFAULT PARAMETERS FOR OPTIONAL PARAMETERS:
        parameters['write_summary'] = False
	parameters['summary_filename'] = None
	parameters['nucl_wat_outputname'] = 'nucleophilic_waters.dat'
	parameters['avg_wat_outputname'] = 'average_waters.dat'
	parameters['center_of_geometry'] = 'COG.xyz'

	# GRABBING PARAMETER VALUES FROM THE CONFIG FILE:
	execfile(config_file,parameters)
	for key, value in parameters.iteritems():
		if value == '':
			print '%s has not been assigned a value. This variable is necessary for the script to run. Please declare this variable within the config file.' %(key)
			sys.exit()

def summary():
	with open('%s' %(parameters['summary_filename']),'w') as f:
		f.write('Using MDAnalysis version: %s\n' %(MDAnalysis.version.__version__))
		f.write('To recreate this analysis, run this line:\n')
		for i in range(len(sys.argv)):
			f.write('%s ' %(sys.argv[i]))
		f.write('\n\n')
		f.write('Parameters used:\n')
		for i in all_parameters:
			f.write('%s = %s \n' %(i,parameters[i]))

# ----------------------------------------
# MAIN:
# CREATING PARAMETER DICTIONARY
parameters = {}
config_parser(config_file)

# ----------------------------------------
# LOAD IN THE ANALYSIS UNIVERSE AND CREATE THE NECESSARY ATOM SELECTIONS
ffprint('Loading Analysis Universe.')
u = MDAnalysis.Universe(parameters['pdb'])
u_all = u.select_atoms('all')
wat = u.select_atoms(parameters['wat_resname'])
u_pocket = u.select_atoms(parameters['pocket_selection'])
atom1 = u.select_atoms(parameters['substrate_atom1'])
atom2 = u.select_atoms(parameters['substrate_atom2'])
atom3 = u.select_atoms(parameters['base_atom1'])
atom4 = u.select_atoms(parameters['base_atom2'])
atom5 = u.select_atoms(parameters['base_atom3'])

# ----------------------------------------
# ANALYSIS OF TRAJECTORIES
start = int(parameters['start'])
end = int(parameters['end'])
timestep = 0
with open(parameters['nucl_wat_outputname'],'w') as W, open(parameters['avg_wat_outputname'],'w') as X, open(parameters['center_of_geometry_filename'],'w') as Y:
	ffprint('Beginning trajectory analysis')
	while start <= end:
		ffprint('Loading trajectory %s' %(start))
		u.load_new(parameters['traj_loc'] %(start,start))
		# Loop through trajectory
		for ts in u.trajectory:
	                # Obtaining COG of pocket; moving origin to this point
			t = u_pocket.center_of_geometry()
			Y.write('1\n  generated by MDAnalysis and RBD\n X         %10.4f         %10.4f         %10.4f\n' %(t[0], t[1], t[2]))	#Writing an xyz trajectory of the center of geometry of the binding pocket; the COG particle is labeled as a dummy atom X
			u_all.translate(-t)
		
			pocket_waters = wat.select_atoms('byres point 0 0 0 %d'%(parameters['pocket_radius']))
			nRes = pocket_waters.n_residues
			X.write('%d\n'%(nRes))

			pos1 = atom1.positions[0]
			pos2 = atom2.positions[0]
                        pos3 = atom3.positions[0]
                        pos4 = atom4.positions[0]
                        pos5 = atom5.positions[0]
			dist,dist2 = euclid_dist(pos1,pos2)
			bond_vector = (pos2 - pos1)/dist	# unitary vector describing the O_{\gamma,\beta} to P_{\gamma} bond

			for i in range(nRes):
				res = pocket_waters.residues[i].resid
				ox_pos = u.select_atoms('resid %s and %s' %(res,parameters['wat_O_name'])).positions[0]
                                h_pos = u.select_atoms('resid %s and %s' %(res,parameters['wat_H_name'])).positions
				
                                attack_dist, dist2 = euclid_dist(pos2,ox_pos)   # measuring the attack distance
				attack_vector = (pos2 - ox_pos)/attack_dist	# unitary vector describing the O_{wat} to P_{\gamma} attack bond
				
				avg_h_pos = np.mean(h_pos,0)	# avg coordinates of the hydrogen atoms of water; this should give coordinates along the dipole moment of water;
				dist, dist2 = euclid_dist(avg_h_pos,ox_pos)
				dipole_vector = (ox_pos - avg_h_pos)/dist	# unitary vector describing the avg_H_{wat} to O_{wat} dipole moment of water
				
                                attack_angle = arccos(dot(bond_vector,attack_vector))*unit_conversion	# angle between the attack vector and the bond vector; describes the angle of nucleophilic attack
				dipole_angle = arccos(dot(bond_vector,dipole_vector))*unit_conversion	# angle between the dipole vector of water and the bond vector; describes the orientation of water with respect to the nucleophilic attack target/leaving group

                                glu_base_dist = np.min([sums((h_pos[0] - pos3)**2)**0.5,sums((h_pos[1] - pos3)**2)**0.5,sums((h_pos[0] - pos4)**2)**0.5,sums((h_pos[1] - pos4)**2)**0.5])       # calculating minimum distance btw water hydrogens and glutamate 118 oxygen atoms.
                                gln_base_dist = np.min([sums((h_pos[0] - pos5)**2)**0.5,sums((h_pos[1] - pos5)**2)**0.5])       # calculating minimum distance btw water hydrogens and glutamine 289 oxygen atoms.

				W.write('%d  %d  %f  %f  %f  %f  %f\n'%(timestep,i,attack_dist,attack_angle,dipole_angle,glu_base_dist,gln_base_dist))
			
			timestep += 1

                print 'Finished analyzing Trajectory', start
		start += 1

if parameters['write_summary']:
	summary()

